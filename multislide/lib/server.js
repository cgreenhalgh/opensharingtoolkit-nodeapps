// Generated by CoffeeScript 1.6.3
(function() {
  var Multislide, ROLEIX, fs, returnFile,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  fs = require('fs');

  ROLEIX = 'roleix';

  returnFile = function(path, data, res) {
    var exi, ext, headers;
    headers = {};
    exi = path.lastIndexOf('.');
    if (exi >= 0) {
      ext = path.substring(exi + 1);
      if (ext === 'js') {
        headers['Content-Type'] = 'application/javascript';
      } else if (ext === 'css') {
        headers['Content-Type'] = 'text/css';
      } else if (ext === 'jpg') {
        headers['Content-Type'] = 'image/jpeg';
      } else if (ext === 'png') {
        headers['Content-Type'] = 'image/png';
      } else if (ext === 'mp3') {
        headers['Content-Type'] = 'audio/mpeg';
      } else if (ext === 'ogg') {
        headers['Content-Type'] = 'audio/ogg';
      }
    }
    console.log("data is " + (typeof data));
    headers['Content-Length'] = data.length;
    res.writeHead(200, headers);
    return res.end(data);
  };

  Multislide = (function() {
    function Multislide(config, assetpath) {
      this.config = config;
      this.assetpath = assetpath;
      this.handler = __bind(this.handler, this);
      console.log("New multislide " + this.config.title);
    }

    Multislide.prototype.handler = function(req, res) {
      var path, qix, self, url;
      self = this;
      console.log("handler for " + req.method + " " + req.url + " on port " + this.port);
      if (req.method !== 'GET') {
        res.writeHead(405);
        return res.end("Method " + req.method + " not allowed");
      }
      url = req.url;
      if (url.indexOf('..') >= 0) {
        res.writeHead(400);
        return res.end("Bad request including .. " + req.url);
      }
      qix = url.indexOf('?');
      if (qix >= 0) {
        url = url.substring(0, qix);
      }
      path = __dirname + '/../public' + url;
      return fs.readFile(path, function(err, data) {
        if (err) {
          path = self.assetpath + url;
          fs.readFile(path, function(err, data) {
            if (err) {
              res.writeHead(404);
              return res.end("Error loading " + path + " for " + res.url);
            }
            console.log("send asset file " + url);
            return returnFile(path, data, res);
          });
          return false;
        }
        console.log("send multislide file " + url);
        return returnFile(path, data, res);
      });
    };

    Multislide.prototype.socketsByRole = {};

    Multislide.prototype.slideIx = 0;

    Multislide.prototype.start = function() {
      var self;
      self = this;
      this.app = require('http').createServer(this.handler);
      this.io = require('socket.io').listen(this.app);
      this.app.listen(8081, function() {});
      this.port = this.app.address().port;
      console.log("multislide running on port " + this.port);
      return this.io.sockets.on('connection', function(socket) {
        return self.onConnection(socket);
      });
    };

    Multislide.prototype.onConnection = function(socket) {
      var self;
      self = this;
      socket.on('disconnect', function() {
        return console.log("Disconnect");
      });
      console.log("Send available-roles (" + this.config.roles.length + ")");
      socket.emit('available-roles', this.config.roles);
      socket.on('announce-role', function(roleix) {
        console.log("announce-role " + roleix);
        return socket.set(ROLEIX, roleix, function() {
          return self.sendSlide(socket);
        });
      });
      socket.on('advance', function(data) {
        console.log("advance from " + data.from);
        if (self.slideIx !== data.from) {
          return console.log("advance for non-current slide " + data.from + " vs " + self.slideIx);
        }
        return self.setSlide(1 + self.slideIx);
      });
      socket.on('back', function(data) {
        console.log("back from " + data.from);
        if (self.slideIx !== data.from) {
          return console.log("back for non-current slide " + data.from + " vs " + self.slideIx);
        }
        if (self.slideIx === 0) {
          return console.log("back from first slide");
        }
        return self.setSlide(self.slideIx - 1);
      });
      return socket.on('restart', function(data) {
        console.log("restart from " + data.from);
        if (self.slideIx !== data.from) {
          return console.log("restart for non-current slide " + data.from + " vs " + self.slideIx);
        }
        return self.setSlide(0);
      });
    };

    Multislide.prototype.sendSlide = function(socket) {
      var slideIx, slides, _ref;
      slideIx = this.slideIx;
      slides = (_ref = this.config['slide-sets'][slideIx]) != null ? _ref.slides : void 0;
      if (slides == null) {
        return console.log("Current slide " + slideIx + " undefined");
      }
      return socket.get(ROLEIX, function(err, roleix) {
        var slide;
        if (err) {
          return console.log("Could not get " + ROLEIX + " for socket");
        }
        roleix = Number(roleix);
        slide = slides[roleix];
        if (slide == null) {
          return console.log("Current slide " + slideIx + " undefined for role " + roleix);
        }
        slide.ix = slideIx;
        console.log("show-slide " + this.slideIx + " for role " + roleix);
        return socket.emit('show-slide', slide);
      });
    };

    Multislide.prototype.setSlide = function(ix) {
      var self;
      console.log("Go to slide " + ix + " from " + this.slideIx);
      this.slideIx = ix;
      self = this;
      return this.io.sockets.clients().forEach(function(socket) {
        return self.sendSlide(socket);
      });
    };

    return Multislide;

  })();

  exports.createServer = function(configpath, assetpath) {
    console.log("read multislide config " + configpath);
    return fs.readFile(configpath, function(err, data) {
      var config, m;
      if (err) {
        console.log("error reading config " + configpath);
        process.exit(-1);
      }
      try {
        config = JSON.parse(data);
      } catch (_error) {
        err = _error;
        console.log("error parsing config " + configpath + ": " + err.message);
        process.exit(-1);
      }
      m = new Multislide(config, assetpath);
      return m.start();
    });
  };

}).call(this);
